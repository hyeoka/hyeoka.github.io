<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>사이다 죽이기</title>
        <style>
            html,
            body {
                height: 100%;
                margin: 0;
                background: #111;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            canvas {
                background: linear-gradient(180deg, #082036, #02121b);
                border: 6px solid #0ea5a4;
                border-radius: 12px;
            }
            #ui {
                position: absolute;
                top: 16px;
                left: 50%;
                transform: translateX(-50%);
                color: #dff7f6;
                font-family: Inter, system-ui, Arial;
                pointer-events: none;
            }
            button {
                position: absolute;
                right: 16px;
                top: 16px;
            }
        </style>
    </head>
    <body>
        <div id="ui">
            <div id="score">Score: 0</div>
            <div id="info" style="opacity: 0.8; font-size: 12px">
                WASD/화살표 이동 · 마우스 클릭 사격
            </div>
        </div>
        <canvas id="c" width="900" height="600"></canvas>
        <button id="restart" style="display: none">Restart</button>

        <script>
            (() => {
                const canvas = document.getElementById('c');
                const ctx = canvas.getContext('2d');
                const W = canvas.width,
                    H = canvas.height;

                // 적 이미지 불러오기
                const enemyImg = new Image();
                enemyImg.src = 'd.jpg'; // 같은 폴더라면 이렇게
                let enemyImgReady = false;
                enemyImg.onload = () => {
                    enemyImgReady = true;
                };

                // 입력
                let keys = {},
                    mouse = { x: W / 2, y: H / 2, down: false };
                addEventListener(
                    'keydown',
                    (e) => (keys[e.key.toLowerCase()] = true)
                );
                addEventListener(
                    'keyup',
                    (e) => (keys[e.key.toLowerCase()] = false)
                );
                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    mouse.x =
                        (e.clientX - rect.left) * (canvas.width / rect.width);
                    mouse.y =
                        (e.clientY - rect.top) * (canvas.height / rect.height);
                });
                canvas.addEventListener(
                    'mousedown',
                    (e) => (mouse.down = true)
                );
                addEventListener('mouseup', (e) => (mouse.down = false));

                // 상태
                let score = 0,
                    gameOver = false;
                const uiScore = document.getElementById('score');
                const restartBtn = document.getElementById('restart');
                restartBtn.addEventListener('click', () => {
                    reset();
                    restartBtn.style.display = 'none';
                });

                // 플레이어
                const player = { x: W / 2, y: H / 2, r: 16, speed: 240 };

                // 배열
                const bullets = [],
                    enemies = [],
                    particles = [];

                // 멘토스 색상 팔레트
                const mentosColors = [
                    '#ffffff',
                    '#ff6666',
                    '#66ccff',
                    '#ffcc00',
                    '#99ff99',
                    '#ff99ff',
                ];

                // 유틸
                function rand(min, max) {
                    return Math.random() * (max - min) + min;
                }
                function dist(a, b, c, d) {
                    const dx = a - c,
                        dy = b - d;
                    return Math.hypot(dx, dy);
                }

                // 발사
                let fireCooldown = 0;
                function tryFire(dt) {
                    fireCooldown -= dt;
                    if (mouse.down && fireCooldown <= 0) {
                        fireCooldown = 0.16;
                        const angle = Math.atan2(
                            mouse.y - player.y,
                            mouse.x - player.x
                        );
                        const c = Math.cos(angle),
                            s = Math.sin(angle);
                        const color =
                            mentosColors[
                                Math.floor(Math.random() * mentosColors.length)
                            ];
                        bullets.push({
                            x: player.x + c * (player.r + 6),
                            y: player.y + s * (player.r + 6),
                            vx: c * 520,
                            vy: s * 520,
                            r: 4,
                            life: 1.2,
                            color,
                        });
                    }
                }

                // 폭발 이펙트
                function makeExplosion(x, y, color, n = 20, spread = 1) {
                    for (let i = 0; i < n; i++) {
                        const a = rand(0, Math.PI * 2);
                        const sp = rand(60, 200) * spread;
                        particles.push({
                            x,
                            y,
                            vx: Math.cos(a) * sp,
                            vy: Math.sin(a) * sp,
                            life: rand(0.6, 1.4),
                            r: rand(2, 4),
                            c: color,
                        });
                    }
                }

                // 적 스폰
                function spawnEnemy() {
                    const side = Math.floor(rand(0, 4));
                    let x, y;
                    if (side === 0) {
                        x = -20;
                        y = rand(0, H);
                    } else if (side === 1) {
                        x = W + 20;
                        y = rand(0, H);
                    } else if (side === 2) {
                        x = rand(0, W);
                        y = -20;
                    } else {
                        x = rand(0, W);
                        y = H + 20;
                    }
                    const size = rand(28, 48);
                    enemies.push({
                        x,
                        y,
                        r: size,
                        spd: rand(40, 100) * (28 / size),
                    });
                }

                // 리셋
                let last = 0,
                    spawnTimer = 0,
                    spawnInterval = 1.2,
                    diffTimer = 0;
                function reset() {
                    score = 0;
                    gameOver = false;
                    player.x = W / 2;
                    player.y = H / 2;
                    bullets.length = 0;
                    enemies.length = 0;
                    particles.length = 0;
                    spawnTimer = 0;
                    spawnInterval = 1.2;
                    diffTimer = 0;
                    uiScore.textContent = 'Score: 0';
                    last = performance.now();
                    loop();
                }

                // 업데이트
                function update(dt) {
                    if (gameOver) return;

                    let dx = 0,
                        dy = 0;
                    if (keys['w'] || keys['arrowup']) dy -= 1;
                    if (keys['s'] || keys['arrowdown']) dy += 1;
                    if (keys['a'] || keys['arrowleft']) dx -= 1;
                    if (keys['d'] || keys['arrowright']) dx += 1;
                    if (dx || dy) {
                        const len = Math.hypot(dx, dy);
                        dx /= len;
                        dy /= len;
                        player.x = Math.max(
                            player.r,
                            Math.min(
                                W - player.r,
                                player.x + dx * player.speed * dt
                            )
                        );
                        player.y = Math.max(
                            player.r,
                            Math.min(
                                H - player.r,
                                player.y + dy * player.speed * dt
                            )
                        );
                    }

                    tryFire(dt);

                    for (let i = bullets.length - 1; i >= 0; i--) {
                        const b = bullets[i];
                        b.x += b.vx * dt;
                        b.y += b.vy * dt;
                        b.life -= dt;
                        if (b.life <= 0) bullets.splice(i, 1);
                    }

                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const e = enemies[i];
                        const a = Math.atan2(player.y - e.y, player.x - e.x);
                        e.x += Math.cos(a) * e.spd * dt;
                        e.y += Math.sin(a) * e.spd * dt;
                        if (
                            dist(e.x, e.y, player.x, player.y) <
                            e.r + player.r - 2
                        ) {
                            makeExplosion(player.x, player.y, '#ff4444', 60, 2);
                            gameOver = true;
                            restartBtn.style.display = 'block';
                        }
                    }

                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const e = enemies[i];
                        for (let j = bullets.length - 1; j >= 0; j--) {
                            const b = bullets[j];
                            if (dist(e.x, e.y, b.x, b.y) < e.r + b.r) {
                                makeExplosion(e.x, e.y, b.color, 40, 1.6);
                                enemies.splice(i, 1);
                                bullets.splice(j, 1);
                                score += 20;
                                uiScore.textContent = 'Score: ' + score;
                                break;
                            }
                        }
                    }

                    for (let i = particles.length - 1; i >= 0; i--) {
                        const p = particles[i];
                        p.x += p.vx * dt;
                        p.y += p.vy * dt;
                        p.vx *= 0.97;
                        p.vy *= 0.97;
                        p.life -= dt;
                        if (p.life <= 0) particles.splice(i, 1);
                    }

                    spawnTimer += dt;
                    diffTimer += dt;
                    if (spawnTimer >= spawnInterval) {
                        spawnTimer = 0;
                        spawnEnemy();
                    }
                    if (diffTimer > 6 && spawnInterval > 0.38) {
                        spawnInterval *= 0.9;
                        diffTimer = 0;
                    }
                }

                // 그리기
                function draw() {
                    ctx.clearRect(0, 0, W, H);

                    const ang = Math.atan2(
                        mouse.y - player.y,
                        mouse.x - player.x
                    );
                    ctx.save();
                    ctx.translate(player.x, player.y);
                    ctx.rotate(ang);
                    ctx.beginPath();
                    ctx.arc(0, 0, player.r, 0, Math.PI * 2);
                    ctx.fillStyle = '#60a5fa';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(player.r, -6);
                    ctx.lineTo(player.r + 10, 0);
                    ctx.lineTo(player.r, 6);
                    ctx.closePath();
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                    ctx.restore();

                    for (const b of bullets) {
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                        ctx.fillStyle = b.color;
                        ctx.fill();
                    }

                    // 적(이미지)
                    for (const e of enemies) {
                        if (enemyImgReady) {
                            ctx.drawImage(
                                enemyImg,
                                e.x - e.r,
                                e.y - e.r,
                                e.r * 2,
                                e.r * 2
                            );
                        } else {
                            ctx.beginPath();
                            ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
                            ctx.fillStyle = '#6ee7b7';
                            ctx.fill();
                        }
                    }

                    for (const p of particles) {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                        ctx.fillStyle = p.c;
                        ctx.globalAlpha = Math.max(0, p.life);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }

                    if (gameOver) {
                        ctx.fillStyle = 'rgba(0,0,0,0.6)';
                        ctx.fillRect(0, 0, W, H);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 36px Inter';
                        ctx.textAlign = 'center';
                        ctx.fillText('Game Over', W / 2, H / 2 - 10);
                        ctx.font = '16px Inter';
                        ctx.fillText('Score: ' + score, W / 2, H / 2 + 22);
                    }
                }

                function loop() {
                    const now = performance.now();
                    let dt = (now - last) / 1000;
                    if (dt > 0.05) dt = 0.05;
                    last = now;
                    update(dt);
                    draw();
                    if (!gameOver) requestAnimationFrame(loop);
                }

                reset();
            })();
        </script>
    </body>
</html>
